{
  "hash": "3758c4e79a6e0a9bd7c3ec23cc29ff4f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"collapse 패키지 소개 v2\"\ndescription: | \n  collapse; fast, flexible, parsimonoius code package for R.\ncategories:\n  - R\n  - statistics\n  - data.table\nauthor:\n  name: \"Hojun LEE\"\n  url: https://github.com/21-HJ\nimage: img/logo.png\nfig_width: 400\ndate: 2024-10-29\nformat: html\nexecute:\n  freeze: true\ndraft: false\nlicense: CC BY-NC\n\n---\n\n\n\n```         \n```\n\n# Introduction\n\n-   **Collapse**\n    1.  C/C++ 기반의 패키지로 큰 데이터셋을 보다 쉽게 다룰 수 있도록 구성됨.\n\n    2.  R code의 성능을 획기적으로 개선하여 대규모 데이터를 **빠르고 효율적**으로 처리함을 목표로 함.\n\n    3.  성능을 극대화함과 동시에, 기존 데이터 조작 framework와 통합할 수 있도록 안정적이고 최적화된 사용자 API를 제공함. \n        (dplyr, tidyverse, data.table 등)\n-   **MAIN FOCUS** -\\> **data.table**과 함께 이용하여 보다 빠르게 연산을 처리하자.\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##setup\n\n#install.packages(\"collapse\")\n\nlibrary(magrittr);library(dplyr);library(data.table) \n\nlibrary(collapse);library(microbenchmark);library(lmtest)\n```\n:::\n\n\n\n## Basic\n\ndata.table처럼 fread & fwrite를 이용하여 csv파일을 처리한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exam data: 09-15\n\ndt <- fread(\"https://raw.githubusercontent.com/jinseob2kim/lecture-snuhlab/master/data/example_g1e.csv\")\ndf <- read.csv(\"https://raw.githubusercontent.com/jinseob2kim/lecture-snuhlab/master/data/example_g1e.csv\")\nfwrite(dt, \"aa.csv\")\n```\n:::\n\n\n\n**Columns**: **'fselect'**로 원하는 열을 불러올 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfselect(dt, 1:3, 13:16) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  334536     200911   162    51    63  19.4\n3:         2009  911867     200903   163    65    82  24.5\n4:         2009  183321     200908   152    51    70  22.1\n5:         2009  942671     200909   159    50    73  19.8\n6:         2009  979358     200912   157    55    73  22.3\n```\n\n\n:::\n\n```{.r .cell-code}\nfselect(dt, EXMD_BZ_YYYY,RN_INDI,HME_YYYYMM )|> head() # fselect(dt, \"EXMD_BZ_YYYY\",\"RN_INDI\",\"HME_YYYYMM\" )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM\n          <int>   <int>      <int>\n1:         2009  562083     200909\n2:         2009  334536     200911\n3:         2009  911867     200903\n4:         2009  183321     200908\n5:         2009  942671     200909\n6:         2009  979358     200912\n```\n\n\n:::\n:::\n\n\n\n**Rows**: **'fsubset()'**로 원하는 행/열을 불러올 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfsubset(dt, 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM Q_PHX_DX_STK Q_PHX_DX_HTDZ Q_PHX_DX_HTN\n          <int>   <int>      <int>        <int>         <int>        <int>\n1:         2009  562083     200909            0             0            1\n2:         2009  334536     200911            0             0            0\n3:         2009  911867     200903            0             0            0\n   Q_PHX_DX_DM Q_PHX_DX_DLD Q_PHX_DX_PTB Q_HBV_AG Q_SMK_YN Q_DRK_FRQ_V09N  HGHT\n         <int>        <int>        <int>    <int>    <int>          <int> <int>\n1:           0            0           NA        3        1              0   144\n2:           0            0           NA        2        1              0   162\n3:           0            0           NA        3        1              0   163\n    WGHT  WSTC   BMI VA_LT VA_RT BP_SYS BP_DIA URN_PROT   HGB   FBS TOT_CHOL\n   <int> <int> <num> <num> <num>  <int>  <int>    <int> <num> <int>    <int>\n1:    61    90  29.4   0.7   0.8    120     80        1  12.6   117      264\n2:    51    63  19.4   0.8   1.0    120     80        1  13.8    96      169\n3:    65    82  24.5   0.7   0.6    130     80        1  15.0   118      216\n      TG   HDL   LDL  CRTN  SGOT  SGPT   GGT   GFR\n   <int> <int> <int> <num> <int> <int> <int> <int>\n1:   128    60   179   0.9    25    20    25    59\n2:    92    70    80   0.9    18    15    28    74\n3:   132    55   134   0.8    26    30    30    79\n```\n\n\n:::\n\n```{.r .cell-code}\n#fsubset(dt, c(1:3, 13:16)) #rows\nfsubset(dt, 1:3, 13:16)  #(dt, row, col)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    HGHT  WGHT  WSTC   BMI\n   <int> <int> <int> <num>\n1:   144    61    90  29.4\n2:   162    51    63  19.4\n3:   163    65    82  24.5\n```\n\n\n:::\n\n```{.r .cell-code}\nfsubset(dt, c(1:nrow(dt)),c(1:3, 13:16)) |> head() #cols\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  334536     200911   162    51    63  19.4\n3:         2009  911867     200903   163    65    82  24.5\n4:         2009  183321     200908   152    51    70  22.1\n5:         2009  942671     200909   159    50    73  19.8\n6:         2009  979358     200912   157    55    73  22.3\n```\n\n\n:::\n\n```{.r .cell-code}\n# fsubset(dt, EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) %>%  fsubset(c(1:3),c(1:3,13:16))\nfsubset(dt, c(1:nrow(dt)),c(1:3, 13:16)) %>% fsubset(EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) |> head() # same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  318669     200904   155    66    78  27.5\n3:         2009  668438     200904   160    71    94  27.7\n4:         2009  560878     200903   144    58    93  28.0\n5:         2009  375694     200906   151    70    94  30.7\n6:         2009  446652     200909   158    64    80  25.6\n```\n\n\n:::\n\n```{.r .cell-code}\nroworder(dt, HGHT) %>% fsubset(EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) %>%\n  fsubset(c(1:nrow(dt)),c(1:3,13:16)) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  560878     200903   144    58    93  28.0\n3:         2011  562083     201111   144    59    88  28.5\n4:         2011  519824     201109   145    58    79  27.6\n5:         2011  914987     201103   145    70    95  33.3\n6:         2012  560878     201208   145    59    85  28.1\n```\n\n\n:::\n:::\n\n\n\n# Collapse package\n\n지금까지 collapse에서의 행/열 처리에 대해 알아보았다. 다음은 collapse에서 보다 빠른 연산 및 데이터 처리를 도와주는 도구들이다.\n\n## Fast Statistical Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.FAST_STAT_FUN\n # [1]  \"fmean\"      \"fmedian\"    \"fmode\"      \"fsum\"       \"fprod\"      \n # [6]  \"fsd\"        \"fvar\"       \"fmin\"       \"fmax\"       \"fnth\"       \n # [11] \"ffirst\"     \"flast\"      \"fnobs\"      \"fndistinct\"\n\n# 데이터 구조에 구애받지않음.\nv1 <- c(1,2,3,4)\nm1 <- matrix(1:50, nrow = 10, ncol = 5)\n \nfmean(v1); fmean(m1); fmean(dt)\nfmode(v1); fmode(m1); fmode(dt)\n# fmean(m1): by columns\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# collapse; baseR과 비교했을 때 보다 빠른 속도를 보인다.\nx <- rnorm(1e7)\nmicrobenchmark(mean(x), fmean(x), fmean(x, nthreads = 4)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                   expr       min        lq      mean    median        uq\n                mean(x) 23.761096 23.786943 23.802908 23.799427 23.815928\n               fmean(x) 15.332085 15.367978 15.388554 15.387914 15.404170\n fmean(x, nthreads = 4)  4.217606  6.684896  7.634676  7.741456  8.499509\n      max neval cld\n 23.94914   100 a  \n 15.57999   100  b \n 11.20740   100   c\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(colMeans(dt), sapply(dt, mean), fmean(dt))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n             expr      min       lq       mean   median        uq      max\n     colMeans(dt) 3154.750 3302.700 3300.31781 3307.968 3312.7130 3641.641\n sapply(dt, mean)  190.076  199.417  208.52219  206.010  215.9145  318.417\n        fmean(dt)   52.889   53.803   56.23603   55.644   56.8805   90.947\n neval cld\n   100 a  \n   100  b \n   100   c\n```\n\n\n:::\n:::\n\n\n\n-   Data size가 더 클 경우, 보다 유용하다. *(GGDC10S: 5000rows, 11cols, ~10% missing values)*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(base = sapply(GGDC10S[6:16], mean, na.rm = TRUE), fmean(GGDC10S[6:16]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                 expr     min      lq     mean   median       uq      max neval\n                 base 412.369 429.161 773.8810 807.4445 818.8705 7949.178   100\n fmean(GGDC10S[6:16])  94.481  95.856 102.7777 103.9790 108.0860  142.060   100\n cld\n  a \n   b\n```\n\n\n:::\n:::\n\n\n\n-   이처럼, **Collapse**는 data 형식에 구애받지 않고, 보다 빠른 속도를 특징으로 하는 package이다.\n\n이들의 문법을 알아보자.\n\n```         \n-   Fast Statistical Functions\n\n  Syntax:\n\nFUN(x, g = NULL, \\[w = NULL,\\] TRA = NULL, \\[na.rm = TRUE\\], use.g.names = TRUE, \\[drop = TRUE,\\] \\[nthreads = 1,\\] ...)\n\n       \nArgument            Description\n      g             grouping vectors / lists of vectors or ’GRP’ object\n      w             a vector of (frequency) weights\n    TRA             a quoted operation to transform x using the statistics\n  na.rm             efficiently skips missing values in x\n  use.g.names       generate names/row-names from g\n  drop              drop dimensions if g = TRA = NULL\n  nthreads          number of threads for OpenMP multithreading\n```\n\n**사용예시** : **fmean**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Weighted Mean\nw <- abs(rnorm(nrow(iris)))\nall.equal(fmean(num_vars(iris), w = w), sapply(num_vars(iris), weighted.mean, w = w))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nwNA <- na_insert(w, prop = 0.05)\nsapply(num_vars(iris), weighted.mean, w = wNA) # weighted.mean(): 결측치를 처리하지 못한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n          NA           NA           NA           NA \n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), w = wNA) #결측치를 자동으로 무시한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.797389     3.048473     3.683776     1.151507 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Grouped Mean\nfmean(iris$Sepal.Length, g = iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    setosa versicolor  virginica \n     5.006      5.936      6.588 \n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), iris$Species)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n\n```{.r .cell-code}\n# Weighted Group Mean\nfmean(num_vars(iris), iris$Species, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa         5.015518    3.460443     1.479887   0.2495797\nversicolor     5.918636    2.698947     4.259102   1.2888099\nvirginica      6.568402    2.959146     5.577613   2.0433786\n```\n\n\n:::\n\n```{.r .cell-code}\n# 속도 상의 이점. \nmicrobenchmark(fmean = fmean(iris$Sepal.Length, iris$Species),\n               tapply = tapply(iris$Sepal.Length, iris$Species, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n   expr    min      lq     mean  median      uq     max neval cld\n  fmean  7.488  7.8230  8.49842  8.2905  8.5785  32.276   100  a \n tapply 46.609 47.8695 49.83706 48.5615 48.9820 152.046   100   b\n```\n\n\n:::\n:::\n\n\n\n## Consideration w/ missing data: 결측치 처리\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#wlddev$GINI, g: country, function: mean, median, min, max, sum, prod\ncollap(wlddev, GINI ~ country, list(mean, median, min, max, sum, prod),\n       na.rm = TRUE, give.names = FALSE) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         country     mean median  min  max   sum         prod\n1    Afghanistan      NaN     NA  Inf -Inf   0.0 1.000000e+00\n2        Albania 31.41111   31.7 27.0 34.6 282.7 2.902042e+13\n3        Algeria 34.36667   35.3 27.6 40.2 103.1 3.916606e+04\n4 American Samoa      NaN     NA  Inf -Inf   0.0 1.000000e+00\n5        Andorra      NaN     NA  Inf -Inf   0.0 1.000000e+00\n6         Angola 48.66667   51.3 42.7 52.0 146.0 1.139065e+05\n```\n\n\n:::\n\n```{.r .cell-code}\n# na.rm=T가 기본값이며, NA를 연산한 값은 모두 NA를 결과값으로 반영함. \ncollap(wlddev, GINI ~ country, list(fmean, fmedian, fmin, fmax, fsum, fprod),\n       give.names = FALSE) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         country    fmean fmedian fmin fmax  fsum        fprod\n1    Afghanistan       NA      NA   NA   NA    NA           NA\n2        Albania 31.41111    31.7 27.0 34.6 282.7 2.902042e+13\n3        Algeria 34.36667    35.3 27.6 40.2 103.1 3.916606e+04\n4 American Samoa       NA      NA   NA   NA    NA           NA\n5        Andorra       NA      NA   NA   NA    NA           NA\n6         Angola 48.66667    51.3 42.7 52.0 146.0 1.139065e+05\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(a = collap(wlddev, GINI ~ country, list(mean, median, min, max, sum, prod),\n                          na.rm = TRUE, give.names = FALSE) |> head(),\n               b=collap(wlddev, GINI ~ country, list(fmean, fmedian, fmin, fmax, fsum, fprod),\n                        give.names = FALSE) |> head())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min       lq       mean   median         uq       max neval cld\n    a 9783.454 9857.552 10483.5492 9942.606 10258.8435 15291.497   100  a \n    b  534.478  577.196   604.1118  615.318   626.4175   855.808   100   b\n```\n\n\n:::\n\n```{.r .cell-code}\n# 속도 상 이점을 다시 한 번 확인할 수 있다.\n```\n:::\n\n\n\n## TRA function\n\n-   TRA function을 이용, 여러 행/열의 연산을 간편하게 처리할 수 있다.\n\n```         \nSyntax:\n  TRA(x, STATS, FUN = \"-\", g = NULL, set = FALSE, ...)\n\n\n  setTRA(x, STATS, FUN = \"-\", g = NULL, ...)\n\n  STATS = vector/matrix/list of statistics\n\n0        \"replace_NA\"     replace missing values in x\n1        \"replace_fill\"   replace data and missing values in x\n2        \"replace\"        replace data but preserve missing values in x\n3        \"-\"              subtract (i.e. center)\n4        \"-+\"             center on overall average statistic\n5        \"/\"              divide (i.e. scale)\n6        \"%\"              compute percentages (i.e. divide and multiply by 100)   \n7        \"+\"              add\n8        \"*\"              multiply\n9        \"%%\"             modulus (i.e. remainder from division by STATS)\n10       \"-%%\"            subtract modulus (i.e. make data divisible by STATS)\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt2 <- as.data.table(iris)\n\nattach(iris)    #data.table에서처럼 변수명을 직접 호출하기 위해 attach를 사용할 수 있다.\n\n# 평균값과의 차: g= Species\nall_obj_equal(Sepal.Length - ave(Sepal.Length, g = Species),\n              fmean(Sepal.Length, g = Species, TRA= \"-\"),\n              TRA(Sepal.Length, fmean(Sepal.Length, g = Species), \"-\", g = Species))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(baseR= Sepal.Length - ave(Sepal.Length, g = Species),\n               fmean = mean(Sepal.Length, g = Species, TRA= \"-\"),\n               TRA_fmean = TRA(Sepal.Length, fmean(Sepal.Length, g = Species), \"-\", g = Species));detach(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n      expr    min      lq     mean  median      uq     max neval cld\n     baseR 57.640 58.9120 61.35788 59.9555 61.2070 156.905   100 a  \n     fmean  3.754  3.9635  4.29474  4.1200  4.2485  19.150   100  b \n TRA_fmean 11.907 12.4290 13.49149 13.0765 13.4220  55.347   100   c\n```\n\n\n:::\n:::\n\n\n\n-   **TRA()**를 사용하기보다 **Fast Statistical Function**에서 **TRA** 기능을 호출하자!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#예시\nnum_vars(dt2) %<>%  na_insert(prop = 0.05)\n\n# NA 값을 median값으로 대체.\nnum_vars(dt2) |> fmedian(iris$Species, TRA = \"replace_NA\", set = TRUE)\n# num_vars(dt2) |> fmean(iris$Species, TRA = \"replace_NA\", set = TRUE) --> mean으로 대체.\n\n\n# 다양한 연산 및 작업을 한 번에 다룰 수 있다.\nmtcars |> ftransform(A = fsum(mpg, TRA = \"%\"),\n                     B = mpg > fmedian(mpg, cyl, TRA = \"replace_fill\"),\n                     C = fmedian(mpg, list(vs, am), wt, \"-\"),\n                     D = fmean(mpg, vs,, 1L) > fmean(mpg, am,, 1L)) |> head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               mpg cyl disp  hp drat    wt  qsec vs am gear carb        A     B\nMazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 3.266449  TRUE\nMazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 3.266449  TRUE\nDatsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 3.546430 FALSE\n                 C     D\nMazda RX4      1.3 FALSE\nMazda RX4 Wag  1.3 FALSE\nDatsun 710    -7.6  TRUE\n```\n\n\n:::\n:::\n\n\n\n## Grouping Object\n\n-   GRP function을 이용, group을 쉽게 연산할 수 있다.\n\n    ```         \n    Syntax:\n\n        GRP(X, by = NULL, sort == TRUE, decreasing = FALSE, na.last = TRUE, \n        return.groups = TRUE, return.order = sort, method = \"auto\", ...)\n    ```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- GRP(iris, by = ~ Species)\nprint(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncollapse grouping object of length 150 with 3 ordered groups\n\nCall: GRP.default(X = iris, by = ~Species), X is sorted\n\nDistribution of group sizes: \n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n     50      50      50      50      50      50 \n\nGroups with sizes: \n    setosa versicolor  virginica \n        50         50         50 \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClass 'GRP'  hidden list of 9\n $ N.groups    : int 3\n $ group.id    : int [1:150] 1 1 1 1 1 1 1 1 1 1 ...\n $ group.sizes : int [1:3] 50 50 50\n $ groups      :'data.frame':\t3 obs. of  1 variable:\n  ..$ Species: Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 2 3\n $ group.vars  : chr \"Species\"\n $ ordered     : Named logi [1:2] TRUE TRUE\n  ..- attr(*, \"names\")= chr [1:2] \"ordered\" \"sorted\"\n $ order       : int [1:150] 1 2 3 4 5 6 7 8 9 10 ...\n  ..- attr(*, \"starts\")= int [1:3] 1 51 101\n  ..- attr(*, \"maxgrpn\")= int 50\n  ..- attr(*, \"sorted\")= logi TRUE\n $ group.starts: int [1:3] 1 51 101\n $ call        : language GRP.default(X = iris, by = ~Species)\n```\n\n\n:::\n\n```{.r .cell-code}\n# GRP 기능- 호출하여 사용하자!\nfmean(num_vars(iris), g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n:::\n\n\n\n## Factors in operation\n\n**Collaspe**는 형식에 구애받지 않는다; factor를 바로 연산할 수 있으며, **qF**로 빠르게 factor를 생성할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- na_insert(rnorm(1e7), prop = 0.01) \ng <- sample.int(1e6, 1e7, TRUE)         \n# grp와 비교\nsystem.time(gg <- GRP(g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.649   0.027   0.677 \n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time(f <- qF(g, na.exclude = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.254   0.044   0.298 \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"      \"na.included\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(fmean(x, g), \n               fmean(x, gg), \n               fmean(x, gg, na.rm = FALSE), \n               fmean(x, f))\n ## Unit: milliseconds\n ##       expr                    min         lq          mean        median\n ## fmean(x, g)                   146.060983  150.493309  155.02585   152.197822\n ## fmean(x, gg)                  25.354564   27.709625   29.48497    29.022157\n ## fmean(x, gg, na.rm = FALSE)   13.184534   13.783585   15.61769    14.128067\n ## fmean(x, f)                   24.847271   27.503661   29.47271    29.248580\n\n# qF를 통해 grp와 유사한 성능 향상을 기대할 수 있다.\n```\n:::\n\n\n\n## Summary: FAST grouping and Ordering\n\n```         \n다양한 기능이 있다. \nGRP()           Fast sorted or unsorted grouping of multivariate data, returns detailed object of class ’GRP’ \nqF()/qG()       Fast generation of factors and quick-group (’qG’) objects from atomic vectors \nfinteraction()  Fast interactions: returns factor or ’qG’ objects \nfdroplevels()   Efficiently remove unused factor levels\n\nradixorder()    Fast ordering and ordered grouping \ngroup()         Fast first-appearance-order grouping: returns ’qG’ object \ngsplit()        Split vector based on ’GRP’ object \ngreorder()      Reorder the results\n\n- that also return ’qG’ objects \ngroupid()       Generalized run-length-type grouping seqid() Grouping of integer sequences \ntimeid()        Grouping of time sequences (based on GCD)\n\ndapply()        Apply a function to rows or columns of data.frame or matrix based objects. \nBY()            Apply a function to vectors or matrix/data frame columns by groups.\n\n-   Specialized Data Transformation Functions \nfbetween()      Fast averaging and (quasi-)centering. \nfwithin()\nfhdbetween()    Higher-Dimensional averaging/centering and linear prediction/partialling out \nfhdwithin()     (powered by fixest’s algorithm for multiple factors).\nfscale()        (advanced) scaling and centering.\n\n-   Time / Panel Series Functions \nfcumsum()       Cumulative sums \nflag()          Lags and leads \nfdiff()         (Quasi-, Log-, Iterated-) differences \nfgrowth()       (Compounded-) growth rates\n\n-    Data manipulation functions\nfselect(),      fsubset(),      fgroup_by(),    [f/set]transform[v](),          \nfmutate(),      fsummarise(),   across(),       roworder[v](),            \ncolorder[v](),  [f/set]rename(),                [set]relabel()\n```\n\n## Collapse는 빠르다!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfdim(wlddev)    ##faster dim for dt. col/row: 13176 13\n\n# 1990년 이후를 기준으로, ODA/POP의 값 (g: region, income, OECD)\nmicrobenchmark( \n  \ndplyr = qDT(wlddev) |>\n        filter(year >= 1990) |>\n        mutate(ODA_POP = ODA / POP) |>\n        group_by(region, income, OECD) |>\n        summarise(across(PCGDP:POP, sum, na.rm = TRUE), .groups = \"drop\") |>\n        arrange(income, desc(PCGDP)),\n\ndata.table = qDT(wlddev)[, ODA_POP := ODA / POP][\n             year >= 1990, lapply(.SD, sum, na.rm = TRUE),\n             by = .(region, income, OECD), .SDcols = PCGDP:ODA_POP][\n             order(income, -PCGDP)],\n\ncollapse_base = qDT(wlddev) |>\n                fsubset(year >= 1990) |>\n                fmutate(ODA_POP = ODA / POP) |>\n                fgroup_by(region, income, OECD) |>\n                fsummarise(across(PCGDP:ODA_POP, sum, na.rm = TRUE)) |>\n                roworder(income, -PCGDP),\n\ncollapse_optimized = qDT(wlddev) |>\n                    fsubset(year >= 1990, region, income, OECD, PCGDP:POP) |>\n                    fmutate(ODA_POP = ODA / POP) |>\n                    fgroup_by(1:3, sort = FALSE) |> fsum() |>\n                    roworder(income, -PCGDP)\n)\n\n\n## Unit: microseconds\n##        expr            min         lq            mean            median          uq            max         neval\n## dplyr                  71955.523   72291.9715    80009.2208\t    72453.1165\t    76902.671   393947.262\t100\t\n## data.table\t          5960.503    6310.7045     7116.6673\t    6721.3450\t    7046.837    18615.736\t  100\t\n## collapse_base\t      859.505     948.2200      1041.1137\t    990.1375\t    1061.864\t 3148.804\t    100\t\n## collapse_optimized\t  442.040     482.9705      542.6927\t    523.6950\t    574.921\t    1036.817\t  100\t\n```\n:::\n\n\n\n## Collapse w/ Fast Statistical Function: 다양한 활용\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 아래 셋은 동일한 결과를 보인다.\n# cyl별 mpg sum\n mtcars %>% ftransform(mpg_sum = fsum(mpg, g = cyl, TRA = \"replace_fill\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% fmutate(mpg_sum = fsum(mpg)) %>% head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4   138.2\nMazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4   138.2\nDatsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1   293.3\nHornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1   138.2\nHornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2   211.4\nValiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1   138.2\nDuster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4   211.4\nMerc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2   293.3\nMerc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2   293.3\nMerc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4   138.2\n```\n\n\n:::\n:::\n\n\n\n-   ad-hoc grouping, often **fastest!**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(a=mtcars %>% ftransform(mpg_sum = fsum(mpg, g = cyl, TRA = \"replace_fill\")),\n               b=mtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")),\n               c=mtcars %>% fgroup_by(cyl) %>% fmutate(mpg_sum = fsum(mpg)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr    min      lq     mean  median      uq     max neval cld\n    a 27.362 28.9525 30.22495 29.9020 31.5925  39.924   100 a  \n    b 64.001 66.0010 68.26108 67.2155 68.9120 114.379   100  b \n    c 78.678 80.4105 84.21481 81.2445 82.4050 264.876   100   c\n```\n\n\n:::\n:::\n\n\n\n-   **ftransform()**은 앞의 **fgroupby**를 무시한다. 아래 둘은 값이 다르다. (**fmutate, fsummarise**만 이전 group을 반영한다.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   138.2\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   138.2\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   293.3\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   138.2\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   211.4\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   138.2\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, TRA = \"replace_fill\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   642.9\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   642.9\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   642.9\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   642.9\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   642.9\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   642.9\n```\n\n\n:::\n:::\n\n\n\n-   위 언급과 같이 **baseR** 의 **\"/\"**보다 **collapse**의 **TRA function**을 이용하는 것이 더 빠르다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n\"/\"=      mtcars |> fgroup_by(cyl) |> fmutate(mpg_prop = mpg / fsum(mpg))      |> head(),     \n\"TRA=/\" = mtcars |> fgroup_by(cyl) |> fmutate(mpg_prop = fsum(mpg, TRA = \"/\")) |> head()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n  expr     min       lq     mean   median       uq     max neval cld\n     / 207.643 210.3915 214.5014 212.7320 215.4790 281.881   100  a \n TRA=/ 196.455 200.0970 205.9386 202.4655 205.0695 471.228   100   b\n```\n\n\n:::\n:::\n\n\n\n-   **fsum**은 grp 별로 연산을 처리하나, sum은 전체를 반영한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> fgroup_by(cyl) |> fmutate(mpg_prop2 = fsum(mpg) / sum(mpg))|> head() #\"!=1\" \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_prop2\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 0.2149634\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 0.2149634\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 0.4562140\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 0.2149634\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 0.3288225\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 0.2149634\n```\n\n\n:::\n:::\n\n\n\n-   자유로운 **%>%** 의 사용\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 아래 둘은 동일하다.\n mtcars %>% fgroup_by(cyl) %>% ftransform(fselect(., hp:qsec) %>% fsum(TRA = \"/\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% fmutate(across(hp:qsec, fsum, TRA = \"/\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp         hp       drat         wt       qsec vs\nMazda RX4         21.0   6  160 0.12850467 0.15537849 0.12007333 0.13080102  0\nMazda RX4 Wag     21.0   6  160 0.12850467 0.15537849 0.13175985 0.13525111  0\nDatsun 710        22.8   4  108 0.10231023 0.08597588 0.09227220 0.08840435  1\nHornet 4 Drive    21.4   6  258 0.12850467 0.12270916 0.14734189 0.15448188  1\nHornet Sportabout 18.7   8  360 0.05974735 0.06967485 0.06144064 0.07248414  0\nValiant           18.1   6  225 0.12266355 0.10996016 0.15857012 0.16068023  1\n                  am gear carb\nMazda RX4          1    4    4\nMazda RX4 Wag      1    4    4\nDatsun 710         1    4    1\nHornet 4 Drive     0    3    1\nHornet Sportabout  0    3    2\nValiant            0    3    1\n```\n\n\n:::\n:::\n\n\n\n-   **set = TRUE**를 통해 원본 데이터에 반영할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\n# mtcars의 열 hp:qsec의 값과 해당하는 g:cyl별 합의 비율.\nmtcars %>% fgroup_by(cyl) %>% fmutate(across(hp:qsec, fsum, TRA = \"/\", set = TRUE)) %>% invisible()\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp         hp       drat         wt       qsec vs\nMazda RX4         21.0   6  160 0.12850467 0.15537849 0.12007333 0.13080102  0\nMazda RX4 Wag     21.0   6  160 0.12850467 0.15537849 0.13175985 0.13525111  0\nDatsun 710        22.8   4  108 0.10231023 0.08597588 0.09227220 0.08840435  1\nHornet 4 Drive    21.4   6  258 0.12850467 0.12270916 0.14734189 0.15448188  1\nHornet Sportabout 18.7   8  360 0.05974735 0.06967485 0.06144064 0.07248414  0\nValiant           18.1   6  225 0.12266355 0.10996016 0.15857012 0.16068023  1\n                  am gear carb\nMazda RX4          1    4    4\nMazda RX4 Wag      1    4    4\nDatsun 710         1    4    1\nHornet 4 Drive     0    3    1\nHornet Sportabout  0    3    2\nValiant            0    3    1\n```\n\n\n:::\n:::\n\n\n\n-   **.apply = FALSE**를 통해 subset group에만 적용할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 각 g:cyl의 hp:qsec까지의 변수에 대한 부분 상관관계\nmtcars %>% fgroup_by(cyl) %>% fsummarise(across(hp:qsec, \\(x) qDF(pwcor(x), \"var\"), .apply = FALSE)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl  var         hp       drat         wt       qsec\n1   4   hp  1.0000000 -0.4702200  0.1598761 -0.1783611\n2   4 drat -0.4702200  1.0000000 -0.4788681 -0.2833656\n3   4   wt  0.1598761 -0.4788681  1.0000000  0.6380214\n4   4 qsec -0.1783611 -0.2833656  0.6380214  1.0000000\n5   6   hp  1.0000000  0.2171636 -0.3062284 -0.6280148\n6   6 drat  0.2171636  1.0000000 -0.3546583 -0.6231083\n```\n\n\n:::\n:::\n\n\n\n## 이름/순번/vectors/정규표현식으로 행/열을 지칭할 수 있다.\n\n```         \nget_vars(x, vars, return = \"names\", regex = FALSE, ...) \nget_vars(x, vars, regex = FALSE, ...) <- value \n\n- 위치도 선택가능하다.\nadd_vars(x, ..., pos = \"end\") \nadd_vars(x, pos = \"end\") <- value \n\n- data type을 지정할 수 있다. \nnum_vars(x, return = \"data\");   cat_vars(x, return = \"data\");   char_vars(x, return = \"data\"); \nfact_vars(x, return = \"data\");  logi_vars(x, return = \"data\");  date_vars(x, return = \"data\") \n\n- replace 또한 가능하다.\nnum_vars(x) <- value;   cat_vars(x) <- value;   char_vars(x) <- value; \nfact_vars(x) <- value;  logi_vars(x) <- value;  date_vars(x) <- value\n```\n\n## Efficient programming\n\n```         \n    > quick data conversion\n-   qDF(),  qDT(),  qTBL(),   qM(),   mrtl(),   mctl()\n    \n-   anyv(x, value) / allv(x, value)     # Faster than any/all(x == value)\n-   allNA(x)                            # Faster than all(is.na(x))\n-   whichv(x, value, invert = F)        # Faster than which(x (!/=)= value)\n-   whichNA(x, invert = FALSE)          # Faster than which((!)is.na(x))\n-   x %(!/=)=% value                    # Infix for whichv(v, value, TRUE/FALSE)\n-   setv(X, v, R, ...)                  # x\\[x(!/=)=v\\]\\<-r / x\\[v\\]\\<-r\\[v\\] (by reference)\n-   setop(X, op, V, rowwise = F)        # Faster than X \\<- X +/-/\\*// V (by reference)\n-   X %(+,-,\\*,/)=% V                   # Infix for setop,()\n-   na_rm(x)                            # Fast: if(anyNA(x)) x\\[!is.na(x)\\] else x,\n-   na_omit(X, cols = NULL, ...)        # Faster na.omit for matrices and data frames\n-   vlengths(X, use.names=TRUE)         # Faster version of lengths()\n-   frange(x, na.rm = TRUE)             # Much faster base::range\n-   fdim(X)                             # Faster dim for data frames\n```\n\n# Collapse and data.table\n\n**data.table**에서 **collapse**의 적용을 알아보자.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT <- qDT(wlddev) # as.data.table(wlddev)\nDT %>% fgroup_by(country) %>% get_vars(9:13) %>% fmean()  #fgroup_by == gby\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   country      PCGDP   LIFEEX     GINI        ODA         POP\n                    <char>      <num>    <num>    <num>      <num>       <num>\n  1:           Afghanistan   483.8351 49.19717       NA 1487548499 18362258.22\n  2:               Albania  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:               Algeria  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4:        American Samoa 10071.0659       NA       NA         NA    43115.10\n  5:               Andorra 40083.0911       NA       NA         NA    51547.35\n ---                                                                          \n212: Virgin Islands (U.S.) 35629.7336 73.71292       NA         NA    92238.53\n213:    West Bank and Gaza  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:           Yemen, Rep.  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:                Zambia  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:              Zimbabwe  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nDT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13] %>%  invisible()\ncollap(DT, ~ country, fmean, cols = 9:13) %>% invisible()     #same\n\nmicrobenchmark(collapse     = DT %>% gby(country) %>% get_vars(9:13) %>% fmean,\n               data.table   = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               data.table2  = DT[, lapply(.SD, fmean, na.rm = TRUE), keyby = country, .SDcols = 9:13])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n        expr      min        lq      mean   median        uq      max neval cld\n    collapse  334.570  368.7865  389.3642  396.088  400.6755  668.870   100 a  \n  data.table 5047.715 5215.1535 5386.4627 5293.606 5492.7620 8787.870   100  b \n data.table2 5215.911 5295.7220 5637.0815 5379.914 5587.5015 9707.914   100   c\n```\n\n\n:::\n:::\n\n\n\n-   *DT\\[, lapply(.SD, fmean,...)\\]*가 *DT\\[, lapply(.SD, mean,...)\\]*보다 느린 것을 확인할 수 있다. \n    **data.table** 내에서 **mean**은 **baseR**의 **mean**이 아닌 **gmean**으로 **data.table**에 최적화되어있다. \n    반면, **lapply**와 함께 **fmean**을 사용하면 최적화된 방식으로 동작하지 않아 오히려 더 느리다.\n\n-   위 방식은 아래와 처리되는 방식이 유사하다. **fmean**을 모든 **group, columns**에 적용하기에 느리다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBY(gv(DT, 9:13), g, fmean) \n```\n:::\n\n\n\n이때, 아래와 같은 방법으로 이를 일정 수준 해결할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n fmean(gv(DT, 9:13), DT$country)\n g <- GRP(DT, \"country\"); add_vars(g[[\"groups\"]], fmean(gv(DT, 9:13), g))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDT <- qDT(wlddev); g <- GRP(DT, \"country\")\n#gv: abbreviation for get_vars()\nmicrobenchmark(a = fmean(gv(DT, 9:13), DT$country),\n               b0= g <- GRP(DT, \"country\"),\n               b = add_vars(g[[\"groups\"]], fmean(gv(DT, 9:13), g)),\n               dt_fmean = DT[, lapply(.SD, fmean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               dt_gmean = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13]) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n     expr      min        lq      mean   median       uq       max neval  cld\n        a  358.543  378.1060  389.9855  391.505  398.437   615.572   100 a   \n       b0   76.665  100.1125  107.3157  111.378  114.803   147.121   100  b  \n        b  224.602  241.6375  257.6594  255.871  265.802   679.694   100 ab  \n dt_fmean 5131.574 5300.4195 5686.7481 5472.694 5572.977 12437.685   100   c \n dt_gmean 5073.098 5293.6580 5446.3542 5399.370 5579.908  6110.983   100    d\n```\n\n\n:::\n:::\n\n\n\n-   **dplyr**의 data %\\>% group_by(...) %\\>% summarize(...) 및 **data.table**의 \\[i, j, by\\] 구문은 \n    데이터 그룹에 함수를 적용하기 위한 보편적인 방식이다. 이는 다양한 함수를 그룹화된 데이터에\n    적용하며, 특히 **data.table**은 몇몇 내장 함수(**min, max, mean** 등)를 GForce; 내부적으로 최적화하여 처리한다.\n\n-   **collapse**는 데이터를 그룹화하여**(fgroup_by, collap)** 통계 및 변환 함수를 처리한다. (by C++)\n\n-   **collapse**의 모든 기능(BY는 예외)은 GForce 최적화가 되어 있지만, **data.table** 내에서 최적화 정도의 차이, \n    **lapply** 적용 상의 문제가 있는 것으로 추정된다.\n\n-   그렇다면 **fmean**을 **data.table**내에서 쓸 수는 없을까.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT[, fmean(.SD, country), .SDcols = 9:13]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          PCGDP   LIFEEX     GINI        ODA         POP\n          <num>    <num>    <num>      <num>       <num>\n  1:   483.8351 49.19717       NA 1487548499 18362258.22\n  2:  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4: 10071.0659       NA       NA         NA    43115.10\n  5: 40083.0911       NA       NA         NA    51547.35\n ---                                                    \n212: 35629.7336 73.71292       NA         NA    92238.53\n213:  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nDT[, fmean(gby(.SD, country)), .SDcols = c(1L, 9:13)] #gby = abbrviation for fgroup_by()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   country      PCGDP   LIFEEX     GINI        ODA         POP\n                    <char>      <num>    <num>    <num>      <num>       <num>\n  1:           Afghanistan   483.8351 49.19717       NA 1487548499 18362258.22\n  2:               Albania  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:               Algeria  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4:        American Samoa 10071.0659       NA       NA         NA    43115.10\n  5:               Andorra 40083.0911       NA       NA         NA    51547.35\n ---                                                                          \n212: Virgin Islands (U.S.) 35629.7336 73.71292       NA         NA    92238.53\n213:    West Bank and Gaza  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:           Yemen, Rep.  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:                Zambia  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:              Zimbabwe  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(collapse        = DT %>% gby(country) %>% get_vars(9:13) %>% fmean,\n               data.table      = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               data.table_base = DT[, lapply(.SD, base::mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               hybrid_bad      = DT[, lapply(.SD, fmean), keyby = country, .SDcols = 9:13],\n               hybrid_ok       = DT[, fmean(gby(.SD, country)), .SDcols = c(1L, 9:13)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n            expr      min        lq      mean   median        uq       max\n        collapse  341.792  366.5840  384.8933  390.777  399.7335   501.416\n      data.table 5125.348 5255.6865 5562.5321 5365.828 5636.5370 11012.503\n data.table_base 2558.182 2589.2545 2626.3920 2615.736 2638.2230  2884.591\n      hybrid_bad 5166.150 5264.3745 5555.3007 5330.985 5526.0495 10046.046\n       hybrid_ok  842.343  883.5925  901.0746  898.846  920.2410   995.945\n neval  cld\n   100 a   \n   100  b  \n   100   c \n   100  b  \n   100    d\n```\n\n\n:::\n:::\n\n\n\n-   **data.table**내에서 **fmean** 등을 같이 쓰는 것은 **바람직하지 않다.**\n\n```         \nDT %>% gby(country) %>% get_vars(9:13) %>% fmean\nfmean(gv(DT, 9:13), DT$country)\n```\n\n-   보다 효율적인 작업을 위해 위와 같이 **data.table** 외에서 처리하는 방식을 사용하자.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#fmean 이외의 예시: fsum\n\n# 국가별 ODA 합산 = 아래는 모두 동일. \nDT[, sum_ODA := sum(ODA, na.rm = TRUE), by = country]\nDT[, sum_ODA := fsum(ODA, country, TRA = \"replace_fill\")]  \nsettfm(DT, sum_ODA = fsum(ODA, country, TRA = \"replace_fill\"))  # settfm/tfm= settransform/ftransform \n\n# 여러 열을 변경할 때 settransform이 ':=' 보다 편리하다. \nsettfm(DT, perc_c_ODA = fsum(ODA, country, TRA = \"%\"),\n           perc_y_ODA = fsum(ODA, year, TRA = \"%\"))\n\nmicrobenchmark(\n  S1 = DT[, sum_ODA := sum(ODA, na.rm = TRUE), by = country],\n  S2 = DT[, sum_ODA := fsum(ODA, country, TRA = \"replace_fill\")],\n  S3 = settfm(DT, sum_ODA = fsum(ODA, country, TRA = \"replace_fill\"))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min        lq      mean    median        uq      max neval cld\n   S1 2080.392 2157.9970 2232.1498 2242.7080 2288.3410 2563.404   100 a  \n   S2  421.740  507.3445  538.3390  535.7035  578.1545  799.340   100  b \n   S3  121.292  180.0820  206.7299  201.0345  235.0795  337.004   100   c\n```\n\n\n:::\n:::\n\n\n\n-   위와 같이 **data.table** 외에서 처리하는 방식을 사용하자.\n\n-   data.table에서 data 처리에 유용한 **collapse** 함수들:\n\n```         \n\"fcumsum()\"   \"fscale()\"    \"fbetween()\"    \"fwithin()\"   \"fhdbetween()\" \n\"fhdwithin()\"   \"flag()\"    \"fdiff()\"       \"fgrowth()\"\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Centering GDP\n#DT[, demean_PCGDP := PCGDP - mean(PCGDP, na.rm = TRUE), by = country]\nDT[, demean_PCGDP := fwithin(PCGDP, country)]\nsettfm(DT, demean_PCGDP = fwithin(PCGDP, country)) #settfm를 사용하자.\n\n# Lagging GDP\n#DT[order(year), lag_PCGDP := shift(PCGDP, 1L), by = country]\nDT[, lag_PCGDP := flag(PCGDP, 1L, country, year)]\n\n\n# Computing a growth rate\n#DT[order(year), growth_PCGDP := (PCGDP / shift(PCGDP, 1L) - 1) * 100, by = country]\nDT[, lag_PCGDP := fgrowth(PCGDP, 1L, 1L, country, year)] # 1 lag, 1 iteration\n\n# Several Growth rates\n#DT[order(year), paste0(\"growth_\", .c(PCGDP, LIFEEX, GINI, ODA)) := (.SD / shift(.SD, 1L) - 1) * 100, by = country, .SDcols = 9:13]\nDT %<>% tfm(gv(., 9:13) %>% fgrowth(1L, 1L, country, year) %>% add_stub(\"growth_\"))\nsettfmv(DT, 9:13, G, 1L, 1L, country, year, apply = FALSE)\n \nresult <- DT[sample(.N, 7)] |> fselect(9:ncol(DT)); print(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       PCGDP LIFEEX  GINI        ODA       POP      sum_ODA perc_c_ODA\n       <num>  <num> <num>      <num>     <num>        <num>      <num>\n1:  598.0675 61.607    NA  161470001  48949924  29002710049  0.5567411\n2: 1223.2034 55.032    NA  959559998  13115131  23032089813  4.1661873\n3:        NA 43.213    NA  254979996  29248643  91042129921  0.2800681\n4: 1101.9787 56.283    NA 1005000000   7086627  42753590080  2.3506798\n5:        NA     NA    NA  322790009     28720   7609940052  4.2416892\n6: 3931.0345 66.926    NA   88650002  26900508  30162480091  0.2939082\n7:  542.0542 56.963    NA 3204889893 837468930 217402459229  1.4741737\n   perc_y_ODA demean_PCGDP lag_PCGDP growth_PCGDP growth_LIFEEX growth_GINI\n        <num>        <num>     <num>        <num>         <num>       <num>\n1:  0.1663325   153.777583 12.674689    12.674689     0.5106536          NA\n2:  1.0646265     3.767466 14.701173    14.701173     4.0381125          NA\n3:  0.7028241           NA        NA           NA     0.6263972          NA\n4:  1.7515717  -109.153605 -3.550449    -3.550449     1.2102140          NA\n5:  0.4978978           NA        NA           NA            NA          NA\n6:  0.1379507  -650.571973  1.814067     1.814067     0.7148124          NA\n7:  5.5856661  -234.271909  7.299421     7.299421     0.7249836          NA\n    growth_ODA growth_POP  G1.PCGDP G1.LIFEEX G1.GINI      G1.ODA     G1.POP\n         <num>      <num>     <num>     <num>   <num>       <num>      <num>\n1:  14.9498112  0.7936664 12.674689 0.5106536      NA  14.9498112  0.7936664\n2:  39.2442542  1.7124987 14.701173 4.0381125      NA  39.2442542  1.7124987\n3:   0.3265795  2.9335342        NA 0.6263972      NA   0.3265795  2.9335342\n4: -15.8256174  3.0669073 -3.550449 1.2102140      NA -15.8256174  3.0669073\n5: -16.6757024 12.6274510        NA        NA      NA -16.6757024 12.6274510\n6:  -5.0246357  2.2327826  1.814067 0.7148124      NA  -5.0246357  2.2327826\n7:   9.9296837  2.1699666  7.299421 0.7249836      NA   9.9296837  2.1699666\n```\n\n\n:::\n:::\n\n\n\n-   := 은 data.table내에서 최적화 정도가 낮아 collapse를 이용하는 것이 대부분의 경우 더 빠르다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  W1 = DT[, demean_PCGDP := PCGDP - mean(PCGDP, na.rm = TRUE), by = country],\n  W2 = DT[, demean_PCGDP := fwithin(PCGDP, country)],\n  L1 = DT[order(year), lag_PCGDP := shift(PCGDP, 1L), by = country],\n  L2 = DT[, lag_PCGDP := flag(PCGDP, 1L, country, year)],\n  L3 = DT[, lag_PCGDP := shift(PCGDP, 1L), by = country], # Not ordered\n  L4 = DT[, lag_PCGDP := flag(PCGDP, 1L, country)] # Not ordered\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min        lq      mean    median       uq       max neval    cld\n   W1 1907.281 1979.7700 2213.1757 2011.0155 2070.968 10277.173   100 a     \n   W2  768.293  805.5075  843.2050  840.9535  865.933  1161.758   100  b    \n   L1 4107.066 4190.2105 4329.4591 4258.0900 4373.160  5072.518   100   c   \n   L2 1273.071 1316.5770 1424.8645 1358.4510 1377.865  8709.820   100    d  \n   L3 2591.240 2637.7440 2710.1965 2678.2500 2708.528  3347.374   100     e \n   L4  427.919  459.2580  501.5867  498.7115  518.322   879.667   100      f\n```\n\n\n:::\n\n```{.r .cell-code}\n# flag와 같은 time series는 우선적으로 재정렬을 하지 않아 분명한 성능 차이가 존재한다. \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- qM(mtcars)\n# matrix to data: mrtl\nmrtl(m, names = T, return = \"data.table\") %>% head(2) # convert: data.table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive Hornet Sportabout Valiant\n       <num>         <num>      <num>          <num>             <num>   <num>\n1:        21            21       22.8           21.4              18.7    18.1\n2:         6             6        4.0            6.0               8.0     6.0\n   Duster 360 Merc 240D Merc 230 Merc 280 Merc 280C Merc 450SE Merc 450SL\n        <num>     <num>    <num>    <num>     <num>      <num>      <num>\n1:       14.3      24.4     22.8     19.2      17.8       16.4       17.3\n2:        8.0       4.0      4.0      6.0       6.0        8.0        8.0\n   Merc 450SLC Cadillac Fleetwood Lincoln Continental Chrysler Imperial\n         <num>              <num>               <num>             <num>\n1:        15.2               10.4                10.4              14.7\n2:         8.0                8.0                 8.0               8.0\n   Fiat 128 Honda Civic Toyota Corolla Toyota Corona Dodge Challenger\n      <num>       <num>          <num>         <num>            <num>\n1:     32.4        30.4           33.9          21.5             15.5\n2:      4.0         4.0            4.0           4.0              8.0\n   AMC Javelin Camaro Z28 Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa\n         <num>      <num>            <num>     <num>         <num>        <num>\n1:        15.2       13.3             19.2      27.3            26         30.4\n2:         8.0        8.0              8.0       4.0             4          4.0\n   Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E\n            <num>        <num>         <num>      <num>\n1:           15.8         19.7            15       21.4\n2:            8.0          6.0             8        4.0\n```\n\n\n:::\n:::\n\n\n\n-   fast linear model: **flm**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1) %>%  \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX))), \"Coef\"), keyby = country] %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <country>\n   country        Coef   Estimate Std. Error    t value    Pr(>|t|)\n    <char>      <char>      <num>      <num>      <num>       <num>\n1: Albania (Intercept) -3.6146411   2.371885 -1.5239527 0.136023086\n2: Albania   G(LIFEEX) 22.1596308   7.288971  3.0401591 0.004325856\n3: Algeria (Intercept)  0.5973329   1.740619  0.3431726 0.732731107\n4: Algeria   G(LIFEEX)  0.8412547   1.689221  0.4980134 0.620390703\n5:  Angola (Intercept) -3.3793976   1.540330 -2.1939445 0.034597175\n6:  Angola   G(LIFEEX)  4.2362895   1.402380  3.0207852 0.004553260\n```\n\n\n:::\n\n```{.r .cell-code}\n#절편과 변화율만 빠르게 알고싶다면 flm w/ mrtl: (no standard errors)\nwlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1L) %>% \n  fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, mrtl(flm(fgrowth(PCGDP)[-1L], \n               cbind(Intercept = 1, LIFEEX = fgrowth(LIFEEX)[-1L])), TRUE), keyby = country] %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <country>\n               country   Intercept     LIFEEX\n                <char>       <num>      <num>\n1:             Albania -3.61464113 22.1596308\n2:             Algeria  0.59733291  0.8412547\n3:              Angola -3.37939760  4.2362895\n4: Antigua and Barbuda -3.11880717 18.8700870\n5:           Argentina  1.14613567 -0.2896305\n6:             Armenia  0.08178344 11.5523992\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  A= wlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1) %>%  \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX))), \"Coef\"), keyby = country] ,\n  \n  B= wlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1L) %>% \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, mrtl(flm(fgrowth(PCGDP)[-1L], \n               cbind(Intercept = 1, LIFEEX = fgrowth(LIFEEX)[-1L])), TRUE), keyby = country]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n expr        min         lq       mean     median        uq       max neval cld\n    A 166.570912 167.508276 172.559989 168.680762 172.24341 344.73358   100  a \n    B   7.115262   7.422762   7.813804   7.526314   7.61188  13.21533   100   b\n```\n\n\n:::\n\n```{.r .cell-code}\n# coeftest + lm + G 를 flm + fgrowth와 같은 collapse식으로 대체하여 큰 속도 이득을 볼 수 있다.\n```\n:::\n\n\n\n-   **collapse** w/ list; **rsplit; rapply2d; get_elem; unlist2d**\n\n\n\n\n\n\n\n**rapply2d()**: **data.table/frame**에 function 적용.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_summary_list <- DT_list %>% \n  rapply2d(lm, formula = G(PCGDP) ~ G(LIFEEX) + B(G(LIFEEX), country)) %>% \n  rapply2d(summary, classes = \"lm\")\n```\n:::\n\n\n\n**get_elem()**: 원하는 부분을 추출, 이후 **unlist2d**를 이용해 **data.table**로 만들 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n lm_summary_list %>%\n  get_elem(\"coefficients\") %>% \n  unlist2d(idcols = .c(Region, Income), row.names = \"Coef\", DT = TRUE) %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                Region              Income                  Coef  Estimate\n                <char>              <char>                <char>     <num>\n1: East Asia & Pacific         High income           (Intercept) 0.5313479\n2: East Asia & Pacific         High income             G(LIFEEX) 2.4935584\n3: East Asia & Pacific         High income B(G(LIFEEX), country) 3.8297123\n4: East Asia & Pacific Lower middle income           (Intercept) 1.3476602\n5: East Asia & Pacific Lower middle income             G(LIFEEX) 0.5238856\n6: East Asia & Pacific Lower middle income B(G(LIFEEX), country) 0.9494439\n   Std. Error   t value    Pr(>|t|)\n        <num>     <num>       <num>\n1:  0.7058550 0.7527720 0.451991327\n2:  0.7586943 3.2866443 0.001095466\n3:  1.6916770 2.2638554 0.024071386\n4:  0.7008556 1.9228785 0.055015131\n5:  0.7574904 0.6916069 0.489478164\n6:  1.2031228 0.7891496 0.430367103\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 물론, 이렇게도 할 수 있다. \nDT[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX) + B(G(LIFEEX), country))), \"Coef\"), \n   keyby = .(region, income)]\n```\n:::\n\n\n\n# Summary\n\n1.  **collapse**는 빠르며, data/memory 측면에서 경제적이다.\n\n2.  **vector, matrix, data.table** 등 데이터 형식에 구애받지 않고 사용가능하다.\n\n3.  (**dplyr, tidyverse, data.table** 등) 기존 **framework**와 통합하여 사용 가능하다.\n\n4.  **data.table**과 혼용하여 쓸 경우, **dt\\[\\]** 내부에서 사용하면 성능이 저하된다. \n    이는 내부적 데이터 처리 과정의 차이에서 기인한다.\n\n5.  **data.table** 형식을 처리할 때는, **아래**와 같은 문법으로 사용해야 이의 효과를 기대할 수 있다.\n\n```         \n권장되지 않음:\n>   DT[order(year), paste0(\"growth_\", .c(PCGDP, LIFEEX, GINI, ODA)) := (.SD / shift(.SD, 1L) - 1) * 100, \n          by = country, .SDcols = 9:13]\n권장됨\n>>    DT %<>% tfm(gv(., 9:13) %>% fgrowth(1L, 1L, country, year) %>% add_stub(\"growth_\"))\n>>    settfmv(DT, 9:13, G, 1L, 1L, country, year, apply = FALSE)\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}